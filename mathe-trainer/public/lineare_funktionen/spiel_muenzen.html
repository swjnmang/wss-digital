<!DOCTYPE html>
<html lang="de">
<head>
    <meta charset="UTF--8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Münzen-Sammler</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Roboto+Mono:wght@400;700&display=swap" rel="stylesheet">
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        body {
            font-family: 'Roboto Mono', monospace;
        }
        canvas {
            background-color: #f0f9ff;
            border: 2px solid #a3a3a3;
            display: block;
            width: 100%;
            height: 100%;
        }
        .input-label {
            font-size: 1.2rem;
            font-weight: 700;
            color: #404040;
        }
        .input-field {
            font-family: 'Roboto Mono', monospace;
            background-color: #e5e5e5;
            color: #171717;
            border: 2px solid #a3a3a3;
            border-radius: 0.5rem;
            padding: 0.25rem 0.5rem;
            font-size: 1.2rem;
            width: 80px;
            text-align: center;
        }
        .ramp-control.active .input-field {
            background-color: #dcfce7; /* Greenish tint for active ramps */
        }
        .difficulty-btn.active {
            background-color: #1d4ed8;
            color: white;
        }
    </style>
</head>
<body class="bg-neutral-200 text-neutral-800 flex flex-col items-center justify-center min-h-screen p-4">

    <div class="w-full max-w-2xl mx-auto bg-white rounded-xl shadow-lg p-6 text-center">
        <a href="index.html" class="text-blue-600 hover:underline mb-4 inline-block">
            &larr; Zurück zur Übersicht
        </a>
        <h1 class="text-3xl md:text-4xl font-bold text-neutral-700 mb-2">Münzen-Sammler</h1>
        <p class="text-neutral-500 mb-4">Baue Rampen, um die Münzen um die Hindernisse in den Eimer zu leiten!</p>
        
        <div class="flex flex-col sm:flex-row justify-between items-center bg-neutral-100 p-3 rounded-lg mb-4 text-xl gap-4">
             <div>
                <span class="font-bold text-neutral-600">Punkte:</span>
                <span id="score" class="font-bold text-amber-500 ml-2">0</span>
             </div>
             <div class="flex gap-2">
                <button id="difficulty-normal" class="difficulty-btn active bg-neutral-300 hover:bg-neutral-400 text-neutral-800 font-bold py-2 px-4 rounded text-sm">Normal</button>
                <button id="difficulty-medium" class="difficulty-btn bg-neutral-300 hover:bg-neutral-400 text-neutral-800 font-bold py-2 px-4 rounded text-sm">Mittel</button>
                <button id="difficulty-hard" class="difficulty-btn bg-neutral-300 hover:bg-neutral-400 text-neutral-800 font-bold py-2 px-4 rounded text-sm">Schwer</button>
             </div>
        </div>

        <div id="canvas-container" class="relative w-full" style="padding-bottom: 75%;"> <!-- 4:3 Aspect ratio -->
            <canvas id="gameCanvas" class="absolute top-0 left-0 w-full h-full rounded-lg"></canvas>
        </div>

        <!-- Steuerung -->
        <div id="controls-container" class="mt-6 grid grid-cols-1 md:grid-cols-2 gap-4 p-4 bg-neutral-100 rounded-lg">
            <!-- Ramp controls will be generated here by JS -->
        </div>
    </div>

    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const scoreEl = document.getElementById('score');
        const controlsContainer = document.getElementById('controls-container');
        const normalBtn = document.getElementById('difficulty-normal');
        const mediumBtn = document.getElementById('difficulty-medium');
        const hardBtn = document.getElementById('difficulty-hard');
        const canvasContainer = document.getElementById('canvas-container');

        let score = 0;
        let coins = [];
        let ramps = [null, null, null, null];
        let bucket = {};
        let obstacles = [];
        let difficulty = 'normal';
        let autoLeveledUpOnce = false;
        let autoLeveledUpTwice = false;
        const RAMP_COLORS = ['#16a34a', '#2563eb', '#ca8a04', '#c026d3'];
        
        let gridRangeX = 10;
        let gridRangeY = 7.5;

        function resizeCanvas() {
            const containerWidth = canvasContainer.clientWidth;
            canvas.width = containerWidth;
            canvas.height = containerWidth * 0.75; // Maintain 4:3 aspect ratio
            gridRangeX = 10;
            gridRangeY = (gridRangeX * canvas.height) / canvas.width;
        }

        function toCanvasX(mathX) { return ((mathX + gridRangeX) / (2 * gridRangeX)) * canvas.width; }
        function toCanvasY(mathY) { return ((-mathY + gridRangeY) / (2 * gridRangeY)) * canvas.height; }

        function drawGrid() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            ctx.strokeStyle = "#d4d4d4";
            ctx.lineWidth = 1;
            for (let i = Math.floor(-gridRangeX); i <= Math.ceil(gridRangeX); i++) {
                ctx.beginPath(); ctx.moveTo(toCanvasX(i), 0); ctx.lineTo(toCanvasX(i), canvas.height); ctx.stroke();
            }
            for (let i = Math.floor(-gridRangeY); i <= Math.ceil(gridRangeY); i++) {
                ctx.beginPath(); ctx.moveTo(0, toCanvasY(i)); ctx.lineTo(canvas.width, toCanvasY(i)); ctx.stroke();
            }
            ctx.strokeStyle = "#a3a3a3"; ctx.lineWidth = 2;
            ctx.beginPath(); ctx.moveTo(0, toCanvasY(0)); ctx.lineTo(canvas.width, toCanvasY(0)); ctx.stroke();
            ctx.beginPath(); ctx.moveTo(toCanvasX(0), 0); ctx.lineTo(toCanvasX(0), canvas.height); ctx.stroke();
        }

        function drawBucket() {
            const x = toCanvasX(bucket.x);
            const y = toCanvasY(bucket.y);
            const w = bucket.width * (canvas.width / (2 * gridRangeX));
            ctx.fillStyle = "#525252";
            ctx.fillRect(x - w / 2, y, w, 30);
        }

        function drawObstacles() {
            obstacles.forEach(obstacle => {
                 const x = toCanvasX(obstacle.x);
                 const y = toCanvasY(obstacle.y);
                 const w = obstacle.width * (canvas.width / (2 * gridRangeX));
                 const h = obstacle.height * (canvas.height / (2 * gridRangeY));
                 ctx.fillStyle = "#dc2626"; // Red color for obstacle
                 ctx.fillRect(x - w / 2, y - h / 2, w, h);
            });
        }

        function drawRamps() {
            ctx.lineWidth = 6;
            ctx.lineCap = 'round';
            ramps.forEach((ramp, index) => {
                if (ramp === null) return;
                ctx.strokeStyle = RAMP_COLORS[index % RAMP_COLORS.length];
                ctx.beginPath();
                const y1 = ramp.m * (-gridRangeX) + ramp.b;
                const y2 = ramp.m * (gridRangeX) + ramp.b;
                ctx.moveTo(toCanvasX(-gridRangeX), toCanvasY(y1));
                ctx.lineTo(toCanvasX(gridRangeX), toCanvasY(y2));
                ctx.stroke();
            });
        }
        
        function spawnCoin() {
            coins.push({
                x: Math.random() * (gridRangeX * 1.8) - gridRangeX * 0.9,
                y: gridRangeY + 1,
                vy: 0.05 + Math.random() * 0.05,
            });
        }
        
        function updateAndDrawCoins() {
            const activeRamps = ramps.filter(r => r !== null);
            for (let i = coins.length - 1; i >= 0; i--) {
                const coin = coins[i];

                const potentialNextY = coin.y - coin.vy;
                let collisionRamp = null;
                let collisionY = -Infinity;

                // Finde die höchste Rampe, mit der die Münze im nächsten Schritt kollidieren würde
                activeRamps.forEach(ramp => {
                    const rampYAtCoinX = ramp.m * coin.x + ramp.b;
                    // Liegt die Rampe zwischen der aktuellen und der potenziellen nächsten Position?
                    if (rampYAtCoinX <= coin.y && rampYAtCoinX >= potentialNextY) {
                        // Wenn mehrere Rampen im Weg sind, nimm die höchste
                        if (rampYAtCoinX > collisionY) {
                            collisionY = rampYAtCoinX;
                            collisionRamp = ramp;
                        }
                    }
                });

                if (collisionRamp) {
                    // Kollision! Setze die Münze auf die Rampe und lasse sie rutschen.
                    coin.y = collisionY; // Exakte Position auf der Rampe
                    const direction = collisionRamp.m < 0 ? 1 : -1; // Rutschrichtung
                    coin.x += direction * 0.1; // X-Position anpassen
                    coin.y = collisionRamp.m * coin.x + collisionRamp.b; // Y-Position an die neue X-Position anpassen
                } else {
                    // Keine Kollision, also freier Fall.
                    coin.y = potentialNextY;
                }
                
                let collidedWithObstacle = false;
                obstacles.forEach(obstacle => {
                    if (coin.x > obstacle.x - obstacle.width / 2 &&
                        coin.x < obstacle.x + obstacle.width / 2 &&
                        coin.y < obstacle.y + obstacle.height / 2 &&
                        coin.y > obstacle.y - obstacle.height / 2) {
                           collidedWithObstacle = true;
                    }
                });
                if(collidedWithObstacle) {
                    coins.splice(i, 1);
                    continue;
                }

                if (coin.y <= bucket.y && Math.abs(coin.x - bucket.x) < bucket.width / 2) {
                    score += 10;
                    scoreEl.textContent = score;
                    coins.splice(i, 1);

                    if (score >= 1000 && difficulty === 'normal' && !autoLeveledUpOnce) {
                        autoLeveledUpOnce = true;
                        switchToDifficulty('medium');
                    }
                    if (score >= 2000 && difficulty === 'medium' && !autoLeveledUpTwice) {
                        autoLeveledUpTwice = true;
                        switchToDifficulty('hard');
                    }
                    continue;
                }
                if (coin.y < -gridRangeY - 2) { coins.splice(i, 1); continue; }
                ctx.fillStyle = "#f59e0b";
                ctx.beginPath();
                ctx.arc(toCanvasX(coin.x), toCanvasY(coin.y), 8, 0, Math.PI * 2);
                ctx.fill();
            }
        }

        function gameLoop() {
            drawGrid();
            drawBucket();
            drawObstacles();
            drawRamps();
            updateAndDrawCoins();
            requestAnimationFrame(gameLoop);
        }

        function setupControls() {
            controlsContainer.innerHTML = '';
            let numControls;
            if (difficulty === 'hard') numControls = 4;
            else if (difficulty === 'medium') numControls = 3;
            else numControls = 2;
            
            controlsContainer.className = `mt-6 grid grid-cols-1 md:grid-cols-2 gap-4 p-4 bg-neutral-100 rounded-lg`;

            for (let i = 0; i < numControls; i++) {
                const controlEl = document.createElement('div');
                controlEl.className = 'ramp-control p-3 rounded-lg border-2';
                controlEl.style.borderColor = RAMP_COLORS[i];
                controlEl.innerHTML = `
                    <h3 class="font-bold text-lg mb-2" style="color: ${RAMP_COLORS[i]}">Rampe ${i + 1}</h3>
                    <div class="flex items-center gap-2 justify-center mb-3">
                        <span class="input-label">y=</span>
                        <input type="number" class="m-input input-field" step="0.1" data-index="${i}">
                        <span class="input-label">x+</span>
                        <input type="number" class="b-input input-field" step="0.5" data-index="${i}">
                    </div>
                    <div class="flex gap-2 justify-center">
                         <button class="build-button bg-emerald-500 hover:bg-emerald-600 text-white font-bold py-2 px-4 rounded text-md w-full" data-index="${i}">Bauen</button>
                         <button class="clear-button bg-rose-500 hover:bg-rose-600 text-white font-bold py-2 px-4 rounded text-md w-full" data-index="${i}" style="display: none;">Löschen</button>
                    </div>
                `;
                controlsContainer.appendChild(controlEl);

                const mInput = controlEl.querySelector('.m-input');
                const bInput = controlEl.querySelector('.b-input');
                const buildBtn = controlEl.querySelector('.build-button');
                const clearBtn = controlEl.querySelector('.clear-button');

                buildBtn.addEventListener('click', () => {
                    const m = parseFloat(mInput.value);
                    const b = parseFloat(bInput.value);
                    if (!isNaN(m) && !isNaN(b)) {
                        ramps[i] = { m, b };
                        controlEl.classList.add('active');
                        buildBtn.textContent = 'Ändern';
                        clearBtn.style.display = 'inline-block';
                    }
                });
                clearBtn.addEventListener('click', () => {
                    ramps[i] = null;
                    controlEl.classList.remove('active');
                    buildBtn.textContent = 'Bauen';
                    clearBtn.style.display = 'none';
                    mInput.value = '';
                    bInput.value = '';
                });
            }
        }
        
        function updateDifficultyButtons() {
            normalBtn.classList.toggle('active', difficulty === 'normal');
            mediumBtn.classList.toggle('active', difficulty === 'medium');
            hardBtn.classList.toggle('active', difficulty === 'hard');
        }

        function resetGame() {
            score = 0;
            scoreEl.textContent = '0';
            coins = [];
            ramps = [null, null, null, null];
            autoLeveledUpOnce = false;
            autoLeveledUpTwice = false;
            setupControls();
            setupNewRound();
        }

        function switchToDifficulty(newDifficulty) {
            difficulty = newDifficulty;
            updateDifficultyButtons();
            ramps = [null, null, null, null];
            setupControls();
            setupNewRound();
        }

        function setupNewRound() {
            bucket = { x: Math.random() * 12 - 6, y: -gridRangeY + 0.5, width: 3 };
            obstacles = [];
            if (difficulty === 'medium') {
                obstacles.push({ x: bucket.x, y: bucket.y + 2.5, width: 5, height: 1 });
            } else if (difficulty === 'hard') {
                obstacles.push({ x: bucket.x, y: bucket.y + 2.5, width: 5, height: 1 });
                // Add a second, different obstacle
                const secondObstacleX = -bucket.x * 0.8; // Place on the opposite side
                obstacles.push({x: secondObstacleX, y: 0, width: 1, height: 4});
            }
        }
        
        normalBtn.addEventListener('click', () => {
            difficulty = 'normal';
            updateDifficultyButtons();
            resetGame();
        });
        mediumBtn.addEventListener('click', () => {
            difficulty = 'medium';
            updateDifficultyButtons();
            resetGame();
        });
        hardBtn.addEventListener('click', () => {
            difficulty = 'hard';
            updateDifficultyButtons();
            resetGame();
        });
        
        window.addEventListener('resize', resizeCanvas);
        resizeCanvas();
        setupControls();
        setupNewRound();
        setInterval(spawnCoin, 400);
        gameLoop();

    </script>
</body>
</html>
